What you probably want is the information stored in the WCS header keywords, which are in the wcs.fits table file that astronometry.net generates; it's one of the available downloads on the Results page. (I'm assuming you're using the web interface, but I imagine it's generated by the command-line version of the code, too.)

The relevant keywords that define the "reference pixel" for the image are:

CRPIX1 = image x-coordinate of reference pixel
CRPIX2 = image y-coordinate of reference pixel
CRVAL1 = right ascension in decimal degrees of reference pixel
CRVAL2 = declination in decimal degrees of reference pixel
(Note that in the "Advanced" section of the upload page, you can specify your own desired reference pixel (CRPIX1,CRPIX2) coordinates, in case you want something other than the somewhat arbitrary values that astronmetry.net determines.)

You also need the transformation ("CD") matrix values, which include the effects of both pixel scale and rotation: CD1_1, CD1_2, CD2_1, CD2_2 .

In principle, to compute the celestial coordinates of any pixel (x,y)
, you would do

RA = CRVAL1 + delta_RA
Dec = CRVAL2 + delta_Dec
where the offset values are computed as

delta_RA = CD1_1 _ (x - CRPIX1) + CD1_2 _ (y - CRPIX2)
delta_Dec = CD2_1 _ (x - CRPIX1) + CD2_2 _ (y - CRPIX2)
This is the basic version of WCS computation; higher-order terms can provide better accuracy, especially over a wide field of view. I think astrometry.net includes "SIP distortions" keywords in wcs.fits, which will improve the accuracy, but I'm not familiar with the associated computations. If you really want the extra accuracy, it's probably best to use something like the WCS code in astropy.

To estimate the accuracy, the thing to do would probably to use the pixel coordinates of the stars with known "reference" coordinates (i.e., true RA,Dec) to compute predicted RA,Dec using the WCS parameters, and compare the predicted values to the known values.
